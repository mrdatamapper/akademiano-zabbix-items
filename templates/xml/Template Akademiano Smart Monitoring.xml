<?xml version="1.0" encoding="UTF-8"?>
<zabbix_export>
  <version>4.4</version>
  <groups>
    <group>
      <name>Templates/Akademiano</name>
    </group>
    <group>
      <name>Templates/Server hardware</name>
    </group>
  </groups>
  <templates>
    <template>
      <template>Template Akademiano Smart Monitoring</template>
      <name>Template Akademiano Smart Monitoring</name>
      <description>https://github.com/v-zhuravlev/zbx-smartctl
3.4 version with dependent items. Please check your UserParameters.
Template version: v1.5</description>
      <groups>
        <group>
          <name>Templates/Akademiano</name>
        </group>
        <group>
          <name>Templates/Server hardware</name>
        </group>
      </groups>
      <applications>
        <application>
          <name>SMART monitoring (smartctl)</name>
        </application>
      </applications>
      <discovery_rules>
        <discovery_rule>
          <name>smartctl-disks-discovery (HDD)</name>
          <type>ZABBIX_ACTIVE</type>
          <key>uHDD.discovery["{$SMARTCTL_STATIC_DISKS}"]</key>
          <delay>1h</delay>
          <filter>
            <conditions>
              <condition>
                <macro>{#SMART_ENABLED}</macro>
                <value>1</value>
                <formulaid>B</formulaid>
              </condition>
              <condition>
                <macro>{#DISKTYPE}</macro>
                <value>0</value>
                <formulaid>A</formulaid>
              </condition>
            </conditions>
          </filter>
          <description>SMARTCTL_STATIC_DISKS - add additional disks in this macro with -d option. Replace all spaces with '_' inside each disk command. Separate multiple disks with space. 
For example, to discover 2 drives behind hardware RAID, set this macro on the host level:

SMARTCTL_STATIC_DISKS = /dev/sda_-d_sat+megaraid,00 /dev/sda_-d_sat+megaraid,01

Useful for disks that cannot be easily discovered such as disks hidden behind RAID or when agent is installed on Windows or Mac where automatic discovery is not so powerful. 

Setting this macro doesn't prevent any automatic attempts to discover disks using smartctl --scan-open and so on.</description>
          <item_prototypes>
            <item_prototype>
              <name>{#DISKNAME}: smartctl</name>
              <key>uHDD.get["{#DISKCMD}"]</key>
              <delay>1h</delay>
              <history>1d</history>
              <trends>0</trends>
              <value_type>TEXT</value_type>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{str("FAILING_NOW")}=1</expression>
                  <name>{#DISKNAME}: one or more SMART attributes are FAILING_NOW</name>
                  <priority>AVERAGE</priority>
                  <description>Check test result output for details.</description>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: SMART status is not OK</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SATA"},ne)}=1 and
{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SAS"},ne)}=1</expression>
                    </dependency>
                    <dependency>
                      <name>{#DISKNAME}: SMART test status: FAILED!</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].str("FAILED!")}=1</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: Test result</name>
              <type>DEPENDENT</type>
              <key>uHDD.health["{#DISKCMD}"]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <value_type>CHAR</value_type>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:SMART overall-health self-assessment test result:|SMART Health Status:) +\b([\S ]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uHDD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{count(#1,{$SMARTCTL_OK_STATUS:"SATA"},ne)}=1 and
{count(#1,{$SMARTCTL_OK_STATUS:"SAS"},ne)}=1</expression>
                  <name>{#DISKNAME}: SMART status is not OK</name>
                  <priority>WARNING</priority>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: SMART test status: FAILED!</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].str("FAILED!")}=1</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{str("FAILED!")}=1</expression>
                  <name>{#DISKNAME}: SMART test status: FAILED!</name>
                  <priority>AVERAGE</priority>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: Device model</name>
              <type>DEPENDENT</type>
              <key>uHDD.model.["{#DISKCMD}"]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <value_type>CHAR</value_type>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:Vendor: +(.+)\nProduct:|[Dd]evice [Mm]odel:|[Mm]odel [Nn]umber:) +(.+)
\1 \2</params>
                </step>
                <step>
                  <type>LTRIM</type>
                  <params>
<![CDATA[ ]]>                  </params>
                </step>
                <step>
                  <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                  <params>{$THROTTLE_HEARTBEAT_LONG}</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uHDD.get["{#DISKCMD}"]</key>
              </master_item>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: Serial number</name>
              <type>DEPENDENT</type>
              <key>uHDD.sn.["{#DISKCMD}"]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <value_type>CHAR</value_type>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>[Ss]erial [Nn]umber: +(.+)
\1</params>
                </step>
                <step>
                  <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                  <params>{$THROTTLE_HEARTBEAT_LONG}</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uHDD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{diff()}=1  and {strlen()}&gt;0</expression>
                  <recovery_mode>NONE</recovery_mode>
                  <name>{#DISKNAME}: Disk has been replaced (new serial number received)</name>
                  <priority>INFO</priority>
                  <description>Last value: {ITEM.LASTVALUE1}.
Device serial number has changed. Ack to close</description>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 5 Reallocated sectors count</name>
              <type>DEPENDENT</type>
              <key>uHDD["{#DISKCMD}",5 Reallocated]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <description>Count of reallocated sectors. The raw value represents a count of the bad sectors that have been found and remapped.Thus, the higher the attribute value, the more sectors the drive has had to reallocate. This value is primarily used as a metric of the life expectancy of the drive; a drive which has had any reallocations at all is significantly more likely to fail in the immediate months.
https://en.wikipedia.org/wiki/S.M.A.R.T.#Known_ATA_S.M.A.R.T._attributes 
For SATA disks, mapped to 'ID 5 Reallocated Sectors Count'
For Kingston disks, mapped to 'ID 5 Retired Block Count'
For SAS disks, number of 'Elements in grown defect list' is used.</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:5 Reallocate.+|5 Retired_Block_Count.+|Elements in grown defect list:)(?:[\t ]+)([0-9]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uHDD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{delta(7d)}&gt;0</expression>
                  <name>{#DISKNAME}: SMART Reallocated Sectors Count has been registered</name>
                  <priority>AVERAGE</priority>
                  <description>Count of reallocated sectors. The raw value represents a count of the bad sectors that have been found and remapped.Thus, the higher the attribute value, the more sectors the drive has had to reallocate. This value is primarily used as a metric of the life expectancy of the drive; a drive which has had any reallocations at all is significantly more likely to fail in the immediate months.

Trigger: Timeouts in 7 days if there are no new reallocated sectors.</description>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: SMART status is not OK</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SATA"},ne)}=1 and
{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SAS"},ne)}=1</expression>
                    </dependency>
                    <dependency>
                      <name>{#DISKNAME}: SMART test status: FAILED!</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].str("FAILED!")}=1</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 197 Current pending sector count</name>
              <type>DEPENDENT</type>
              <key>uHDD["{#DISKCMD}",Current_Pending_Sector]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <description>SATA: ID 197 Current Pending Sector Count. Count of "unstable" sectors (waiting to be remapped, because of unrecoverable read errors). If an unstable sector is subsequently read successfully, the sector is remapped and this value is decreased. Read errors on a sector will not remap the sector immediately (since the correct value cannot be read and so the value to remap is not known, and also it might become readable later); instead, the drive firmware remembers that the sector needs to be remapped, and will remap it the next time it's written.
However, some drives will not immediately remap such sectors when written; instead the drive will first attempt to write to the problem sector and if the write operation is successful then the sector will be marked good (in this case, the "Reallocation Event Count" (0xC4) will not be increased). This is a serious shortcoming, for if such a drive contains marginal sectors that consistently fail only after some time has passed following a successful write operation, then the drive will never remap these problem sectors.
https://en.wikipedia.org/wiki/S.M.A.R.T.#Known_ATA_S.M.A.R.T._attributes
SAS: Not supported.</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>197 Current_Pending_Sector.+ ([0-9]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uHDD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{delta(3d)}&gt;0</expression>
                  <name>{#DISKNAME}: SMART Current Pending Sector counter incremented</name>
                  <priority>WARNING</priority>
                  <description>Count of "unstable" sectors (waiting to be remapped, because of unrecoverable read errors). If an unstable sector is subsequently read successfully, the sector is remapped and this value is decreased. Read errors on a sector will not remap the sector immediately (since the correct value cannot be read and so the value to remap is not known, and also it might become readable later); instead, the drive firmware remembers that the sector needs to be remapped, and will remap it the next time it's written.
However, some drives will not immediately remap such sectors when written; instead the drive will first attempt to write to the problem sector and if the write operation is successful then the sector will be marked good (in this case, the "Reallocation Event Count" (0xC4) will not be increased). This is a serious shortcoming, for if such a drive contains marginal sectors that consistently fail only after some time has passed following a successful write operation, then the drive will never remap these problem sectors.

Triiger: Timeouts in 3 days if ther are no new sectors</description>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: SMART Reallocated Sectors Count has been registered</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD["{#DISKCMD}",5 Reallocated].delta(7d)}&gt;0</expression>
                    </dependency>
                    <dependency>
                      <name>{#DISKNAME}: SMART status is not OK</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SATA"},ne)}=1 and
{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SAS"},ne)}=1</expression>
                    </dependency>
                    <dependency>
                      <name>{#DISKNAME}: SMART test status: FAILED!</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].str("FAILED!")}=1</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 198 Uncorrectable errors count</name>
              <type>DEPENDENT</type>
              <key>uHDD["{#DISKCMD}",Offline_Uncorrectable]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <description>SATA: ID 198 (Offline) Uncorrectable Sector Count. The total count of uncorrectable errors when reading/writing a sector. A rise in the value of this attribute indicates defects of the disk surface and/or problems in the mechanical subsystem.
https://en.wikipedia.org/wiki/S.M.A.R.T.#Known_ATA_S.M.A.R.T._attributes
SAS: error counter log should be parsed with JS in Zabbix 4.2: read+write
"Error counter log
           Errors Corrected by           Total   Correction     Gigabytes    Total
               ECC          rereads/    errors   algorithm      processed    uncorrected
           fast | delayed   rewrites  corrected  invocations   [10^9 bytes]  errors
read:    2242530    24029   1718309   2266559      30372     409777.659           0
write:   1685701     2629      5464   1688330       2636      35228.365           0
verify:     4400        2         2      4402          2        432.531           0". Should be added to SSD as well.</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>Offline_Uncorrectable.+ ([0-9]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uHDD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{delta(7d)}&gt;0</expression>
                  <name>{#DISKNAME}: SMART (Offline) Uncorrectable Sector Count has been registered</name>
                  <priority>AVERAGE</priority>
                  <description>The total count of uncorrectable errors when reading/writing a sector. A rise in the value of this attribute indicates defects of the disk surface and/or problems in the mechanical subsystem.

Trigger: Timeouts in 7 days if there are no new reallocated sectors.</description>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: SMART status is not OK</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SATA"},ne)}=1 and
{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SAS"},ne)}=1</expression>
                    </dependency>
                    <dependency>
                      <name>{#DISKNAME}: SMART test status: FAILED!</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD.health["{#DISKCMD}"].str("FAILED!")}=1</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 9 Power on hours</name>
              <type>DEPENDENT</type>
              <key>uHDD["{#DISKCMD}",Power_On]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <units>s</units>
              <description>Count of hours in power-on state. The raw value of this attribute shows total count of hours (or minutes, or seconds, depending on manufacturer) in power-on state.
"By default, the total expected lifetime of a hard disk in perfect condition is defined as 5 years (running every day and night on all days). This is equal to 1825 days in 24/7 mode or 43800 hours."

On some pre-2005 drives, this raw value may advance erratically and/or "wrap around" (reset to zero periodically).
https://en.wikipedia.org/wiki/S.M.A.R.T.#Known_ATA_S.M.A.R.T._attributes</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:Power_On_Hours.+ |Accumulated power on time, hours:minutes |Power On Hours:.+ )([0-9]+)
\1</params>
                </step>
                <step>
                  <type>MULTIPLIER</type>
                  <params>3600</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uHDD.get["{#DISKCMD}"]</key>
              </master_item>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 10 Spin retry count</name>
              <type>DEPENDENT</type>
              <key>uHDD["{#DISKCMD}",Spin_Retry_Count]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <description>SATA: ID 10 Spin_Retry_Count. Count of retry of spin start attempts. This attribute stores a total count of the spin start attempts to reach the fully operational speed (under the condition that the first attempt was unsuccessful). An increase of this attribute value is a sign of problems in the hard disk mechanical subsystem.</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>10 Spin_Retry_Count.+ ([0-9]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uHDD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{delta(7d)}&gt;0</expression>
                  <name>{#DISKNAME}: SMART Spin Retry Count has been registered</name>
                  <url>https://kb.acronis.com/content/9110</url>
                  <priority>AVERAGE</priority>
                  <description>Spin retry event is logged each time the drive was unable to spin its platters up to the rated rotation speed in the due time. Spin-up attempt was aborted and retried. This typically indicates severe controller or bearing problem, but may be sometimes caused by power supply problems.
Trigger: Timeouts in 7 days if there are no spin retry events.</description>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 190/194 Temperature</name>
              <type>DEPENDENT</type>
              <key>uHDD["{#DISKCMD}",Temperature_Celsius]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>90d</trends>
              <units>°С</units>
              <description>Current drive temperature.
SATA: Parses value from attribute ID 194 or ID 190.
SAS: Supported
NVMe: Supported</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:194 Temperature[^(\n]+|Airflow_Temperature[^(\n]+|Drive Temperature:|Temperature:) +([0-9]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uHDD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{avg(5m)}&gt;{$TEMP_CRIT:"HDD"} and
{last()}&lt;100</expression>
                  <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                  <recovery_expression>{avg(5m)}&lt;{$TEMP_CRIT:"HDD"}-3</recovery_expression>
                  <name>{#DISKNAME}: Disk temperature: {ITEM.LASTVALUE}</name>
                  <priority>AVERAGE</priority>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{avg(5m)}&gt;{$TEMP_WARN:"HDD"}</expression>
                  <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                  <recovery_expression>{avg(5m)}&lt;{$TEMP_WARN:"HDD"}-3</recovery_expression>
                  <name>{#DISKNAME}: Disk temperature: {ITEM.LASTVALUE}</name>
                  <priority>WARNING</priority>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: Disk temperature: {ITEM.LASTVALUE}</name>
                      <expression>{Template Akademiano Smart Monitoring:uHDD["{#DISKCMD}",Temperature_Celsius].avg(5m)}&gt;{$TEMP_CRIT:"HDD"} and
{Template Akademiano Smart Monitoring:uHDD["{#DISKCMD}",Temperature_Celsius].last()}&lt;100</expression>
                      <recovery_expression>{Template Akademiano Smart Monitoring:uHDD["{#DISKCMD}",Temperature_Celsius].avg(5m)}&lt;{$TEMP_CRIT:"HDD"}-3</recovery_expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 199 CRC error count</name>
              <type>DEPENDENT</type>
              <key>uHDD["{#DISKCMD}",UDMA_CRC_Error]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <description>SATA: ID 199 CRC Error Count. The count of errors in data transfer via the interface cable as determined by ICRC (Interface Cyclic Redundancy Check).
SAS: mapped to 'Non-medium error count'
NVMe: mapped to 'Media and Data Integrity Errors'</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:UDMA_CRC_Error|CRC_Error_Count|Non-medium error count:|Media and Data Integrity Errors:).+ ([0-9]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uHDD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{last()}&gt;100 and {delta(1d)}&gt;0</expression>
                  <name>{#DISKNAME}: SMART UltraDMA CRC Error Count too high: {ITEM.LASTVALUE}. Check cable!</name>
                  <url>http://www.z-a-recovery.com/man-smart.htm</url>
                  <priority>AVERAGE</priority>
                  <description>Low value of this attribute typically indicates that something is wrong with the connectors and/or cables. Disk-to-host transfers are protected by CRC error detection code when Ultra-DMA 66 or 100 is used. So if the data gets garbled between the disk and the host machine, the receiving controller senses this and the retransmission is initiated. Such a situation is called "UDMA CRC error". Once the problem is rectified (typically by replacing a cable), the attribute value returns to the normal levels pretty quick.

Triger: Timeouts in 1 day if there are no new errors.</description>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
          </item_prototypes>
        </discovery_rule>
        <discovery_rule>
          <name>smartctl-disks-discovery (SSD)</name>
          <type>ZABBIX_ACTIVE</type>
          <key>uSSD.discovery["{$SMARTCTL_STATIC_DISKS}"]</key>
          <delay>1h</delay>
          <filter>
            <conditions>
              <condition>
                <macro>{#SMART_ENABLED}</macro>
                <value>1</value>
                <formulaid>B</formulaid>
              </condition>
              <condition>
                <macro>{#DISKTYPE}</macro>
                <value>1</value>
                <formulaid>A</formulaid>
              </condition>
            </conditions>
          </filter>
          <description>SMARTCTL_STATIC_DISKS - add additional disks in this macro with -d option. Replace all spaces with '_' inside each disk command. Separate multiple disks with space. 
For example, to discover 2 drives behind hardware RAID, set this macro on the host level:

SMARTCTL_STATIC_DISKS = /dev/sda_-d_sat+megaraid,00 /dev/sda_-d_sat+megaraid,01

Useful for disks that cannot be easily discovered such as disks hidden behind RAID or when agent is installed on Windows or Mac where automatic discovery is not so powerful. 

Setting this macro doesn't prevent any automatic attempts to discover disks using smartctl --scan-open and so on.</description>
          <item_prototypes>
            <item_prototype>
              <name>{#DISKNAME}: smartctl</name>
              <key>uSSD.get["{#DISKCMD}"]</key>
              <delay>5m</delay>
              <history>1d</history>
              <trends>0</trends>
              <value_type>TEXT</value_type>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{str("FAILING_NOW")}=1</expression>
                  <name>{#DISKNAME}: one or more SMART attributes are FAILING_NOW</name>
                  <priority>AVERAGE</priority>
                  <description>Check test result output for details.</description>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: SMART status is not OK</name>
                      <expression>{Template Akademiano Smart Monitoring:uSSD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SATA"},ne)}=1 and
{Template Akademiano Smart Monitoring:uSSD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SAS"},ne)}=1</expression>
                    </dependency>
                    <dependency>
                      <name>{#DISKNAME}: SMART test status: FAILED!</name>
                      <expression>{Template Akademiano Smart Monitoring:uSSD.health["{#DISKCMD}"].str("FAILED!")}=1</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: Test result</name>
              <type>DEPENDENT</type>
              <key>uSSD.health["{#DISKCMD}"]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <value_type>CHAR</value_type>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:SMART overall-health self-assessment test result:|SMART Health Status:) +\b([\S ]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uSSD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{count(#1,{$SMARTCTL_OK_STATUS:"SATA"},ne)}=1 and
{count(#1,{$SMARTCTL_OK_STATUS:"SAS"},ne)}=1</expression>
                  <name>{#DISKNAME}: SMART status is not OK</name>
                  <priority>WARNING</priority>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: SMART test status: FAILED!</name>
                      <expression>{Template Akademiano Smart Monitoring:uSSD.health["{#DISKCMD}"].str("FAILED!")}=1</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{str("FAILED!")}=1</expression>
                  <name>{#DISKNAME}: SMART test status: FAILED!</name>
                  <priority>AVERAGE</priority>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: Device model</name>
              <type>DEPENDENT</type>
              <key>uSSD.model.["{#DISKCMD}"]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <value_type>CHAR</value_type>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:Vendor: +(.+)\nProduct:|[Dd]evice [Mm]odel:|[Mm]odel [Nn]umber:) +(.+)
\1 \2</params>
                </step>
                <step>
                  <type>LTRIM</type>
                  <params>
<![CDATA[ ]]>                  </params>
                </step>
                <step>
                  <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                  <params>{$THROTTLE_HEARTBEAT_LONG}</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uSSD.get["{#DISKCMD}"]</key>
              </master_item>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: Serial number</name>
              <type>DEPENDENT</type>
              <key>uSSD.sn.["{#DISKCMD}"]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <value_type>CHAR</value_type>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>[Ss]erial [Nn]umber: +(.+)
\1</params>
                </step>
                <step>
                  <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                  <params>{$THROTTLE_HEARTBEAT_LONG}</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uSSD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{diff()}=1  and {strlen()}&gt;0</expression>
                  <recovery_mode>NONE</recovery_mode>
                  <name>{#DISKNAME}: Disk has been replaced (new serial number received)</name>
                  <priority>INFO</priority>
                  <description>Last value: {ITEM.LASTVALUE1}.
Device serial number has changed. Ack to close</description>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 5 Reallocated sectors count</name>
              <type>DEPENDENT</type>
              <key>uSSD["{#DISKCMD}",5 Reallocated]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <description>Count of reallocated sectors. The raw value represents a count of the bad sectors that have been found and remapped.Thus, the higher the attribute value, the more sectors the drive has had to reallocate. This value is primarily used as a metric of the life expectancy of the drive; a drive which has had any reallocations at all is significantly more likely to fail in the immediate months.
https://en.wikipedia.org/wiki/S.M.A.R.T.#Known_ATA_S.M.A.R.T._attributes 
For SATA disks, mapped to 'ID 5 Reallocated Sectors Count'
For Kingston disks, mapped to 'ID 5 Retired Block Count'
For SAS disks, number of 'Elements in grown defect list' is used.</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:5 Reallocate.+|5 Retired_Block_Count.+|Elements in grown defect list:)(?:[\t ]+)([0-9]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uSSD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{delta(7d)}&gt;0</expression>
                  <name>{#DISKNAME}: SMART Reallocated Sectors Count has been registered</name>
                  <priority>AVERAGE</priority>
                  <description>Count of reallocated sectors. The raw value represents a count of the bad sectors that have been found and remapped.Thus, the higher the attribute value, the more sectors the drive has had to reallocate. This value is primarily used as a metric of the life expectancy of the drive; a drive which has had any reallocations at all is significantly more likely to fail in the immediate months.

Trigger: Timeouts in 7 days if there are no new reallocated sectors.</description>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: SMART status is not OK</name>
                      <expression>{Template Akademiano Smart Monitoring:uSSD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SATA"},ne)}=1 and
{Template Akademiano Smart Monitoring:uSSD.health["{#DISKCMD}"].count(#1,{$SMARTCTL_OK_STATUS:"SAS"},ne)}=1</expression>
                    </dependency>
                    <dependency>
                      <name>{#DISKNAME}: SMART test status: FAILED!</name>
                      <expression>{Template Akademiano Smart Monitoring:uSSD.health["{#DISKCMD}"].str("FAILED!")}=1</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 9 Power on hours</name>
              <type>DEPENDENT</type>
              <key>uSSD["{#DISKCMD}",Power_On]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <units>s</units>
              <description>Count of hours in power-on state. The raw value of this attribute shows total count of hours (or minutes, or seconds, depending on manufacturer) in power-on state.
"By default, the total expected lifetime of a hard disk in perfect condition is defined as 5 years (running every day and night on all days). This is equal to 1825 days in 24/7 mode or 43800 hours."

On some pre-2005 drives, this raw value may advance erratically and/or "wrap around" (reset to zero periodically).
https://en.wikipedia.org/wiki/S.M.A.R.T.#Known_ATA_S.M.A.R.T._attributes</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:Power_On_Hours.+ |Accumulated power on time, hours:minutes |Power On Hours:.+ )([0-9]+)
\1</params>
                </step>
                <step>
                  <type>MULTIPLIER</type>
                  <params>3600</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uSSD.get["{#DISKCMD}"]</key>
              </master_item>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 177/202/233 SSD wearout</name>
              <type>DEPENDENT</type>
              <key>uSSD["{#DISKCMD}",SSD wearout]</key>
              <delay>0</delay>
              <history>7d</history>
              <units>%</units>
              <description>SATA: Multiple IDs are used, depending on the vendor: 177 Wear Leveling Count:
"The Wear Leveling Count (WLC) SMART value gives us all the data we need. The current value stands for the remaining endurance of the drive in percentage, meaning that it starts from 100 and decreases linearly as the drive is written to. The raw WLC value counts the consumed P/E cycles, so if these two values are monitored while writing to the drive, sooner than later we will find the spot where the normalized value drops by one."
http://www.anandtech.com/show/8239/update-on-samsung-850-pro-endurance-vnand-die-size

Number of erase/program cycles per block on average. This attribute is intended to be an indicator of imminent wear-out. Normalized Equation: 100 – ( 100 * Average Erase Count / NAND max rated number of erase cycles)

233 Media Wearout Indicator:
Intel SSDs report a normalized value from 100, a new drive, to a minimum of 1. It decreases while the NAND erase cycles increase from 0 to the maximum-rated cycles.
202 Percent_Lifetime_Used:
A value of 0% indicates that 100% of the expected lifetime has been used.
SAS: 'Percentage used endurance indicator:' can be used, but it must inversed: 100%-used first. For that Zabbix 4.2 preprocessing is required.
NVMe: 'Available Spare:' value is used, where 100% idicated new drive and 0% indicates that 100% of the expected lifetime has been used.</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:(?:177 Wear_Leveling_Count|202 Percent_Lifetime_Used|202 Percent_Lifetime_Remain|230 Media_Wearout_Indicator|233 Media_Wearout_Indicator|231 SSD_Life_Left) +0x[0-9a-z]+|Available Spare:) +([0-9]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uSSD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{last()}&lt;5</expression>
                  <name>{#DISKNAME}: SSD wearout (&lt;5% left)</name>
                  <priority>AVERAGE</priority>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{last()}&lt;10</expression>
                  <name>{#DISKNAME}: SSD wearout (&lt;10% left)</name>
                  <priority>WARNING</priority>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: SSD wearout (&lt;5% left)</name>
                      <expression>{Template Akademiano Smart Monitoring:uSSD["{#DISKCMD}",SSD wearout].last()}&lt;5</expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 190/194 Temperature</name>
              <type>DEPENDENT</type>
              <key>uSSD["{#DISKCMD}",Temperature_Celsius]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>90d</trends>
              <units>°С</units>
              <description>Current drive temperature.
SATA: Parses value from attribute ID 194 or ID 190.
SAS: Supported
NVMe: Supported</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:194 Temperature[^(\n]+|Airflow_Temperature[^(\n]+|Drive Temperature:|Temperature:) +([0-9]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uSSD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{avg(5m)}&gt;{$TEMP_CRIT:"HDD"} and
{last()}&lt;100</expression>
                  <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                  <recovery_expression>{avg(5m)}&lt;{$TEMP_CRIT:"HDD"}-3</recovery_expression>
                  <name>{#DISKNAME}: Disk temperature: {ITEM.LASTVALUE}</name>
                  <priority>AVERAGE</priority>
                </trigger_prototype>
                <trigger_prototype>
                  <expression>{avg(5m)}&gt;{$TEMP_WARN:"HDD"}</expression>
                  <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                  <recovery_expression>{avg(5m)}&lt;{$TEMP_WARN:"HDD"}-3</recovery_expression>
                  <name>{#DISKNAME}: Disk temperature: {ITEM.LASTVALUE}</name>
                  <priority>WARNING</priority>
                  <dependencies>
                    <dependency>
                      <name>{#DISKNAME}: Disk temperature: {ITEM.LASTVALUE}</name>
                      <expression>{Template Akademiano Smart Monitoring:uSSD["{#DISKCMD}",Temperature_Celsius].avg(5m)}&gt;{$TEMP_CRIT:"HDD"} and
{Template Akademiano Smart Monitoring:uSSD["{#DISKCMD}",Temperature_Celsius].last()}&lt;100</expression>
                      <recovery_expression>{Template Akademiano Smart Monitoring:uSSD["{#DISKCMD}",Temperature_Celsius].avg(5m)}&lt;{$TEMP_CRIT:"HDD"}-3</recovery_expression>
                    </dependency>
                  </dependencies>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
            <item_prototype>
              <name>{#DISKNAME}: ID 199 CRC error count</name>
              <type>DEPENDENT</type>
              <key>uSSD["{#DISKCMD}",UDMA_CRC_Error]</key>
              <delay>0</delay>
              <history>7d</history>
              <trends>0</trends>
              <description>SATA: ID 199 CRC Error Count. The count of errors in data transfer via the interface cable as determined by ICRC (Interface Cyclic Redundancy Check).
SAS: mapped to 'Non-medium error count'
NVMe: mapped to 'Media and Data Integrity Errors'</description>
              <applications>
                <application>
                  <name>SMART monitoring (smartctl)</name>
                </application>
              </applications>
              <preprocessing>
                <step>
                  <type>REGEX</type>
                  <params>(?:UDMA_CRC_Error|CRC_Error_Count|Non-medium error count:|Media and Data Integrity Errors:).+ ([0-9]+)
\1</params>
                </step>
              </preprocessing>
              <master_item>
                <key>uSSD.get["{#DISKCMD}"]</key>
              </master_item>
              <trigger_prototypes>
                <trigger_prototype>
                  <expression>{last()}&gt;100 and {delta(1d)}&gt;0</expression>
                  <name>{#DISKNAME}: SMART UltraDMA CRC Error Count too high: {ITEM.LASTVALUE}. Check cable!</name>
                  <url>http://www.z-a-recovery.com/man-smart.htm</url>
                  <priority>AVERAGE</priority>
                  <description>Low value of this attribute typically indicates that something is wrong with the connectors and/or cables. Disk-to-host transfers are protected by CRC error detection code when Ultra-DMA 66 or 100 is used. So if the data gets garbled between the disk and the host machine, the receiving controller senses this and the retransmission is initiated. Such a situation is called "UDMA CRC error". Once the problem is rectified (typically by replacing a cable), the attribute value returns to the normal levels pretty quick.

Triger: Timeouts in 1 day if there are no new errors.</description>
                </trigger_prototype>
              </trigger_prototypes>
            </item_prototype>
          </item_prototypes>
        </discovery_rule>
      </discovery_rules>
      <macros>
        <macro>
          <macro>{$SMARTCTL_OK_STATUS:"SAS"}</macro>
          <value>OK</value>
        </macro>
        <macro>
          <macro>{$SMARTCTL_OK_STATUS:"SATA"}</macro>
          <value>PASSED</value>
        </macro>
        <macro>
          <macro>{$SMARTCTL_STATIC_DISKS}</macro>
        </macro>
        <macro>
          <macro>{$TEMP_CRIT:"HDD"}</macro>
          <value>65</value>
        </macro>
        <macro>
          <macro>{$TEMP_WARN:"HDD"}</macro>
          <value>50</value>
        </macro>
        <macro>
          <macro>{$THROTTLE_HEARTBEAT_FAST}</macro>
          <value>5m</value>
        </macro>
        <macro>
          <macro>{$THROTTLE_HEARTBEAT_LONG}</macro>
          <value>1d</value>
        </macro>
        <macro>
          <macro>{$THROTTLE_HEARTBEAT_MIDDLE}</macro>
          <value>1h</value>
        </macro>
        <macro>
          <macro>{$THROTTLE_HEARTBEAT_SHORT}</macro>
          <value>15m</value>
        </macro>
      </macros>
    </template>
  </templates>
</zabbix_export>
